# chapter7. 병렬 데이터 처리와 성능

---

**chapter7의 핵심** ✨

병렬로 데이터를 어떻게 처리하는지 알아보고 병렬이 항상 최선의 방식인지 고민해 보자!

---

## 병렬 스트림

**병렬 스트림**이란 각각의 스레드에서 처리할 수 있도록 스트림 요소를 여러 청크로 분할한 스트림이다. 따라서 병렬 스트림을 이용하면 모든 멀티코어 프로세서가 각각의 청크를 처리하도록 할당할 수 있다. 😎

변경 방법은 아주 간단하게 stream 대신 parallelStream을 호출하면 된다.

### 1. 스트림

```java
  public static long sequentialSum(long n) {
    return Stream.iterate(1L, i -> i + 1) // 무한 자연수 스트림 생성
                 .limit(n) // n개 이하로 제한
                 .reduce(0L, Long::sum); // 모든 숫자를 더하는 스트림 리듀싱 연산
  }
```

<br>

### 2. 전통 자바 방식

```java
  public static long iterativeSum(long n) {
    long result = 0;
    for (long i = 0; i <= n; i++) {
      result += i;
    }
    return result;
  }
```

n이 커진다면 병렬로 처리하는 게 좋을 거다. 

그치만 병렬... 말만 쉽지 몇 개의 스레드를 사용해야 할지, 동기화는 어떤 식으로 처리할지 머리가 아프다... 😵

이럴 때 병렬 스트림을 사용하면 깔끔하게 문제를 해결할 수 있다.

<br>

### 3. 순차 스트림을 병렬 스트림으로 변환하기

```java
  public static long parallelSum(long n) {
    return Stream.iterate(1L, i -> i + 1)
                 .limit(n)
                 .parallel()
                 .reduce(0L, Long::sum);
  }
```

예전에 봤던 예시랑 똑같지만 이번엔 스트림이 여러 청크로 분할되어 병렬로 수행할 수 있다는 점이 다르다!

![image](https://user-images.githubusercontent.com/62419307/206664012-ec8bc75d-9c21-489e-a79a-ca31f93afbb6.png)

parallel을 호출한다고 해도 스트림 자체에는 변화가 없다. 대신 이후 연산이 병렬로 수행해야 한다는 의미로 boolean 플래그가 설정된다. 반대로 sequential로 병렬 스트림을 순차 스트림으로 바꿀 수 있다.

→ parallel과 sequential 두 메서드 중 최종적으로 호출된 메서드가 전체 파이프라인에 영향을 미친다.

<br>

## 스트림 성능 측정

그러면 무조건 병렬 스트림이 짱일까? 🤔 이럴 땐 직접 실행시간을 측정하는 것이 좋다.

테스트 결과는 이렇다 (두둥!)

1. 순차적 스트림

2. 전통 자바 방식 (for)

3. 병렬 스트림

<br>

약간 엥? 스러운 결과가 나왔다... 병렬 스트림이 최고가 아니었어...? 

여기엔 두 가지 이유가 있다.

+ 박싱, 언박싱 연산이 필요하다.

+ 반복 작업은 병렬로 수행할 수 있는 독립 단위로 나누기가 어렵다.

이런 식으로 병렬 프로그래밍이 항상 최선의 방식이 될 수는 없다. 심지어 오용할 경우 전체 프로그램의 성능이 더 나빠질 수 있다.

따라서, 병렬 프로그래밍이 어떤 식으로 실행이 되는지 이해할 필요가 있다.

<br>

## 더 특화된 메서드 사용

그러면 어떻게 효과적으로 병렬 연산을 사용할 수 있을까? 

예를 들어 LongStream.rangeClosed 라는 메서드는 iterate에 비해 두 가지 장점이 있다.

+ 기본형 long을 사용하므로 박싱과 언박싱 오버헤드가 사라진다

+ 쉽게 청크로 분할할 수 있는 숫자 범위를 생산한다.

<br>

아니... 언박싱 오버헤드가 그렇게 크다고? 싶지만 그렇다.

그래서 어떤 알고리즘을 병렬화하는 에 중점을 두는 것보다 적절한 자료구조를 선택하는 것이 더 중요하기도 하다.

<br>

```java
public static long parallelRangedSum(long n) {
    return LongStream.rangeClosed(1, n)
                     .parallel()
                     .reduce(0L, Long::sum);
  }
```

위와 같이 함수형 프로그래밍을 올바르게 사용하여 코드 작성 시 드디어 병렬 스트림이 더 빠른 성능을 보인다.

- 병렬 스트림

- 순차적 스트림

- 전통 자바 방식 (for)

<br>

## 병렬 스트림의 올바른 사용법

아까 설명했던 것처럼 항상 병렬 스트림이 빠른 것은 아니다. 오히려 올바르게 사용하지 않는다면 성능 문제가 발생할 수 있다.

병렬화를 이용하려면 스트림을 재귀적으로 분할해야 하고 서브스트림에 리듀싱 연산을 할당하고 최종적으로 하나의 값으로 합쳐야 한다.

또한, 공유된 누적자를 사용할 경우 race condition 문제가 발생할 수 있다. 그렇기 때문에 병렬 스트림이 올바르게 동작하려면 공유된 가변 상태를 피해야 한다.

📌 참고

[race condition이란...?](https://github.com/hjyeon-n/BE_TIL/blob/master/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C_KOCW/10.%20Process%20Synchronization%201.md)

<br>

## 병렬 스트림 효과적으로 사용하기

+ 병렬 스트림이 항상 성능이 빠른 건 아니기 때문에 직접 측정하자.

+ 박싱 오버헤드를 주의하자. 되도록이면 기본형 특화 스트림을 사용하는 것이 좋다.

+ 순차 스트림보다 병렬 스트림에서 성능이 떨어지는 연산이 있다.
  ex) limit, findFirst

+ 스트림에서 수행하는 전체 파이프라인 연산 비용을 고려해라.

+ 소량의 데이터에서는 병렬 스트림이 도움되지 않는다.

+ 스트림을 구성하는 자료구조가 적절한지 확인하자.

+ 스트림의 특성과 파이프라인의 중간 연산이 스트림의 특성을 어떻게 바꾸는지에 따라 분해 과정의 성능이 달라질 수 있다.

+ 최종 연산의 병합 과정 비용도 고려해야 한다.

<br>

## 포크/조인 프레임워크

포크/조인 프레임워크는 병렬화할 수 있는 작업을 재귀적으로 작은 작업으로 분할한 다음에 서브태스크 각각의 결과를 합쳐서 전체 결과를 만들도록 설계되었다.

![image](https://user-images.githubusercontent.com/62419307/206672885-70ed087b-3f3e-44c8-aaba-a5cfe1fdd541.png)

<br>

### 작업 훔치기

이론적으로는 코어 개수만큼 병렬화된 태스크로 작업 부하를 분할하면 모든 cpu 코어에서 태스크를 실행하고 동시에 끝난다.

하지만... 현실은 그렇지 않다... 😂

그래서 나온 방법이 **작업 훔치기** 기법이다. 다른 스레드가 바쁘게 일하고 있는데 한 스레드가 작업을 마치면 그대로 유휴 상태로 넘어가는 게 아니라 바쁘게 일하는 스레드의 작업을 훔쳐온다. 이 작업을 모든 큐가 빌 때까지 반복한다.

![image](https://user-images.githubusercontent.com/62419307/206674085-aba218b0-89b3-4e1d-aca0-76e7929651f1.png)

<br>

## 정리

+ 내부 반복을 이용하면 명시적으로 다른 스레드를 사용하지 않고도 스트림을 병렬로 처리할 수 있다.

+ 병렬 처리가 항상 빠른 것은 아니기 때문에 성능을 직접 측정해 봐야 한다.

+ 데이터가 아주 많거나 각 요소를 처리하는 데 오랜 시간이 걸릴 때 병렬 스트림으로 실행하면 성능을 높일 수 있다.
