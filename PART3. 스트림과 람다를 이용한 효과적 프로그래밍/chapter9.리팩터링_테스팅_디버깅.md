# chapter9. 리팩터링, 테스팅, 디버깅

**람다로 코드 리팩토링 하기**

<br>

## 람다로 가독성과 유연성을 높이려면 어떻게 리팩토링 해야하는가?
- 람다의 메소드참조 + 동작파라미터화 => 가독성, 유연성 up

### 코드의 가독성이란?
    - 다른 사람도 쉽게 이해 + 유지보수 할 수 있는 코드
    - 의도가 명확한 코드
    - 간결한 코드
    - by 람다, 메서드 참조, 스트림을 통해 개선 가능

1. 익명클래스(장황)를 람다 표현식(간결)으로 리팩토링
- 하나의 추상 메서드를 가지는 익명 클래스를 람다로 변경 가능
```java
Runnable r = new Runnable() {
    void run(){
        System.out.println("Hi");
    }
}

Runnable rx = () -> System.out.println("Hi");
```
- 한계
    - 모든 익명클래스를 변환 불가능, 섀도 변수 불가능, context overloading 으로 모호함


2. 람다를 메서드 참조로 리팩토링
- 람다는 익명함수이므로 뭘 하는지 그 의도를 코드를 읽어야만 알 수 있음
- 메서드 참조를 이용하면 메서드명으로 의도 명확하게 전달 가능
- 정적 헬퍼 메소드(comparing, maxBy, sum, summingInt... Collectors API..) 사용하는 것으로도 명확한 의도 전달 가능


3. 명령형을 스트림으로 리팩토링 
- for, while 반복문을 stream 으로 변경하자
    - stream 이 데이터 처리 파이프라인의 의도를 명확하게 보여주기 때문 + 최적화/멀티코어 활용은 덤


### 코드의 유연성이란?
- 람다를 전달해서 계속 변하는 요구사항에 쉽게 대응하는 코드로!

- 함수형 인터페이스 적용
    - 조건부 연기
        - 특정 조건에서만 특정 코드를 실행하거나 데이터를 생성하도록 연기할 수 있음
        ```java
        logger.log(Level.FINER, ()-> func()) //Supplier : 리스너 콜백 같은 개념?

        //구현된 interface
        void log(Level level, Supplier msgSupplier){
            log(level, msgSupplier.get()); //캡슐화, 클라에 코드 숨겨짐
        }
        ```

    - 실행 어라운드
        - 반복되는 준비, 종료과정의 코드를 람다로 변환하자
        - ex) 리소스를 할당, 헤제하는 코드
    
### 객체지향 디자인패턴 리팩터링
- 디자인패턴에 람다가 만나면?

1. 전략패턴
- 런타임에 적절한 알고리즘(strategy) 선택하는 패턴
- 방식
    - Strategy 인터페이스를 구현하는 여러 전략들
    - 전략 객체를 사용하는 한개 이상의 클라이언트
- 람다를 이용하면?
    - strategy 를 class 로 구현하지 않고 람다로 직접 전달 가능
    - 장점 : 전략을 캡슐화가능

2. 템플릿 메소드 패턴
- 개요를 제시한 다음, **일부를 고칠 수 있는 유연함**을 제공해야할  때 선택하는 패턴
- 추상 클래스를 상속해서 child 가 각자 구현

- 람다를 이용하면?
    - 추상클래스 상속받지 않고 람다나 메서드 참조로 추가하거나 수정할 컴포넌트 구현 가능



3. 옵저버 패턴
- 특정 이벤트(Subject)가 발생했을때 구독한 옵저버들에게 알림을 보낼때 선택하는 패턴
- 람다를 이용하면?
    - 옵저버를 인스턴스화하지 않고 람다에 직접 전달

**주의**
- 코드가 간단한 경우에만 람다로 구현하는게 좋다. 복잡하면? 명시적으로 클래스 만들어서 구현하는게 낫다.

4. 의무체인 패턴
- 동작을 chaining 해서 다음 객체에 전달할때 사용하는 패턴(pipe)
- 람다를 이용하면?
    - 애초에 함수체이닝이랑 비슷한 형태
    - 객체를 UnaryOperator<>로 만들고 andThen() 으로 체이닝


5. 팩토리 패턴
- 인스턴스를 찍어내는 로직을 외부에 노출하지 않고 만들어내기 위해 사용하는 패턴
- 람다를 사용하면?
    - collection 에 미리 인스턴스 supplier 를 넣어놓고 뽑아서 사용 <- supplier 니까 호출 전까지는 생성하는게 아니다.


<br>

## 람다 테스팅

- 람다는 익명함수인데 유닛테스트를 작성하는 방법은?
    - 람다는 함수형 인터페이스 객체를 return
    - 람다를 static 필드에 저장해놓고 @Test코드에서 호출하는 방식으로 테스트 가능
    - 람다를 사용하는 메소드 자체를 호출해서 테스트
    - 복잡한 람다는 개별 메소드로 분할
    - high order function 도 어차피 함수형 인터페이스 return 하므로 같은 방식으로 테스트


## 람다 디버깅

- stack trace 확인
    - 람다는 익명함수이므로 스택트레이스에 메소드 이름이 안나오고 언제는 나오고 엉망진창임.
    - 아직 해결 안된 부분(?)

- 로깅
    - 각각의 스트림 함수 처리들을 로깅하는 방법은? peek()
        - forEach() 처럼 실제 스트림을 소비하지 않으면서 스트림 파이프라인 중 요소마다 로깅할 수 있음.(왠지 이름이 queue 사용했을 느낌)